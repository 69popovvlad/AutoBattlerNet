# Тестовое задание на позицию Unity Network Developer

# Оглавнление
- [Кратко](#кратко)
- [Выборы и аргументы](#выборы-и-аргументы)
  - [Сетевое решение](#сетевое-решение)
  - [Сетевая архитектура](#сетевая-архитектура)
  - [Архитектура проекта](#архитектура-проекта)
  - [Общее](#общее)
- [Что улучшил бы дальше](#что-улучшил-бы-дальше)
- [Пункты задания](#пункты-задания)
- [Запуск](#запуск)

# Кратко
- Клиент-хост: на хост уходит **только инпуты** клиентов, хост просчитывает мир.
- Компоненты для пространственного разбиения и симуляции: `ChunkSimManager`, `ChunkGridBehaviour`.
- DI без тяжелых фреймворков: свой лёгкий [Ioc](https://github.com/Fur-Fighters-Frenzy/Core.Ioc) (правда недописан).

## Выборы и аргументы

# Сетевое решение
**Выбрал:** FishNet. Причины:
- Готовые RPC с атрибутами `Server/Client` и модификаторами.
- Настраиваемые тики отправки/синхронизации.
- Инструменты для эмуляции сети (latency, packet loss).
- Базовые компоненты и UI для быстрого прототипа.

**Альтернатива:** [LiteNetLib](https://github.com/RevenantX/LiteNetLib) — меньше оверхеда, но потребует времени на свою репликацию/пакетизацию. Релевантно при **массовой** синхронизации объектов и жёстких требованиях к трафику.

### Сетевая архитектура
**Подход:** не использовал синхронизацию состояний FishNet.
Для этого жанра достаточно эмулировать всё на сервере и стримить только входные данные игрока.

Хотел уменьшить кол-во тяжелых вызовов обновлений **NetworkBehaviour**, поэтому создал централизированные апдейтеры:

`ChunkSimManager` + `ChunkGridBehaviour`:
- Быстрый поиск сущностей по сетке (чёткая локальность).
- Симуляция пачками по чанкам.
- Задел под **адаптивную частоту** обновлений: рядом с игроком — чаще, далеко — реже (экономия трафика и CPU).

### Архитектура проекта
**DI:** собственный простой [Ioc](https://github.com/Fur-Fighters-Frenzy/Core.Ioc) (правда недописан).  
Почему не Extenject: не хотелось тащить тяжелый контейнер и городить инстансеры ради прототипа.

### Общее
- Таймеры сейчас «нечестные»: накопленную дельту я не перераспределяю, погрешность не компенсируется.
- Chunk batching: приоритетная синхронизация ближних к игроку сущностей; дальние — пониженная частота/LOD.

### Что улучшил бы дальше 
- Выкинул бы `GameplayContext`: добавлен для прототипа, но городит связанности и создаёт глобального управленца.
- Камера: я сделал её ужасно она трясется и кажется что лагает сеть, надо делать плавный ghost для персонажа.
- Если в проекте будут тысячи единиц сущностей - подумал бы над ECS.
- Доделал бы свой Chunk batching
- Большая связность компонентов: нужен полноценный DI-паттерн для монобехов.
- Еще не нравится ивент получения урона. Вообще сделать бы Bucket для сообщений и слушателей,
чтобы по сети отправлять действия центролизованно с последующим распределением по сущностям или типам сообщений.
- Ну и по-мелочи, просто потому что очень много нужно было сделать.

## Пункты задания

### Основная часть

* [X] Маленькая ограниченная арена (top-down), камера закреплена на локальном игроке.
* [X] Движение игрока в плоскости (WASD), игрок не выходит за пределы арены.
* [X] Игрок смотрит в сторону ближайшего противника; если противников нет — по направлению движения.
* [X] Автоматическая атака: projectile с кулдауном, направление — взгляд игрока.
* [X] Попадание projectile наносит урон первому врагу по пути; враг умирает после нескольких попаданий.
* [X] Два типа врагов — визуально различимы, разные скорости движения.
* [X] Поведение врагов: при спавне выбирают ближайшего игрока и движутся к нему;
  * [X] наносят урон при контакте. 
* [X] Спавн врагов: непрерывный с интервалом;
  * [X] опционально ограничение максимального числа активных врагов. 
* [X] Визуальный эффект получения урона у игрока.
* [X] UI: счётчик активных врагов.
* [X] UI: пинг.
* [X] UI: отображение пропускной способности сети (bandwidth).
* [X] Сетевая часть (минимум):

    * [X] Синхронизация позиций игроков.
    * [X] Спавн и попадания projectile’ов (корректная репликация попаданий).
    * [X] Движение/поведение противников синхронизировано по сети.
    * [X] Синхронизация получения урона (для игрока и для противников).
    * [X] Синхронизация счётчика врагов.

### Дополнительная часть

* [X] Кнопка для спавна дополнительных юнитов (ручной спавн).
* [X] Второй тип projectile — самонаводящийся на цель.
* [X] Использование батчинга/роллбэка для синхронизации позиций противников.
* [X] Возможность искусственно увеличить задержку (пинг) для тестирования поведения при высоком пинге.
* [X] Описание в README, что и как бы вы улучшили при наличии дополнительного времени.

### Сдача задания (чеклист)

* [X] Репозиторий с проектом (Git).
* [X] Файл `README.md` в корне (этот файл должен содержать: как запустить Host/Client, какие порты/адреса используются, выбранный сетевой подход и обоснование).
* [X] Пояснение выбранной сетевой библиотеки (например, FishNet) и краткое обоснование выбора.
* [X] (Опционально) описание других решений и их причины.
* [X] (Опционально) Билд Windows x64.

### Окружение / требования

* [X] Unity версия: 6000.0.58f2
* [X] Сетевая библиотека: выбрать и обосновать (FishNet предпочитаем, но допускаются другие).


### [Полный текст задания](Docs%2FTask_C%23_Unity_Network_Developer.pdf)

# Запуск
- Запускаем Unity и выбираете `Net_2_editors`, у нас откроется два редактора, один сам создаст хост и сам к себе подключится как клиент, а второй подключится как клиент.
- Либо запускаем билд дважды на одном дейвайсе, на одном нажимаем `Start Server` и `Start Client` на втором только `Start Client`
